
current commit notepad:

allowing users to create an author as well as select already made author

To Do for Rails Project:

[ ] make partials for forms for all relevant view classes
[ ] require login for all pages for now
[ ] For SF_Lit Fanvorites:  LitFanGenre Make genre model for has many assoc with title and has many through with author
[ ] Make separate model for fp_creator to make funding_projects and be associated with user
[ ] Make separate model for fp_commenter to comment on funding_projects and be associated with user
[ ] Make separate model for fp_contributor to make pledges to funding_projects and be associated with user
[ ] Complete #ready_for_countdown class method
[ ] Complete #ready_for_countdown class method
[ ] make sure Facebook signup works
[ ] For all relevant views: fields should be enclosed within a fields_with_errors class and error messages describing the validation failures must be present within the view on all relevant views
[ ] Add more validations important for security
[ ] Make sure all validations work
[ ] Finish out unwritten CRUD actions
    editig address will just be a part of edit user form, not at a separate link
[ ] Clean up all code for submission
[ ] video runthrough
[ ] blog

 

Future: 

[ ] Make Fanvorite static pages for literature, film, and games
[ ] Make new fan pages based on author, title, and genre links in All SF Fanvorites
[ ] Make created fan pages based on author, title, and genre links in sections for All SF Fanvorite formats
[ ] Try to persist address
[ ] Refactor pledge amount logic in funding_project#show?
[ ] make living story feature where a user is both a ls_creator and a ls_participant, ls_creator creates it and ls_partipant adds to it through comments but they're directly below the creator's original beginning ... which user is typing will be at the side ... if it's a free for all that might be part of the fun ... make a contest with decent prizes 
[ ] include remaining attributes for fp_creator to new funding_project or make a separate model/interface
[ ] Use aliases for other relationships (comment, categories, etc.)
[ ] getting funding_project#show to include a new form for making a comment associated with the project
[ ] Nest funding_project_categories under funding_project
[ ] Add how many days to go and how many backers for funding_project
[ ] Give funding_project_creator choice to be same as user for login or not?
[ ] Make funding_project category a nested attribute to choose when making a new funding_project
[ ] Make new funding_project only possible with admin login
[ ] category a nested attribute to choose when making a new funding_project
[ ] Make index of users only available with admin login
[ ] Make landing pages for all sections
[ ] Finish comments feature for projects
[ ] Refactor to include navbar: Your Profile
[ ] add authentication for admin ... make admin controller in controllers/admin but figure out authentication Monban; https://roberteshleman.com/blog/2014/08/14/using-rails-namespaces-for-admin-actions/
[ ] refactor for Model.find
[ ] Add JS snippet to prevent backsies
[ ] add feature: Which number of project it is for a user is :experience attribute to be a feature mostly connected to funding_project model
[ ] add last time logged in for project creators
[ ] Make a class scope method for all funding_projects that have met 80% funding
[ ] Make a custom route for countdown_projects
[ ] Change name into first name middle name last name entries ... nest them perhaps
[ ] Make form validations for user: must have first and last name, email must match best regex I can find, password must have at least one capital letter, 1 number, and 1 symbol and be 8 characters login
[ ] Change address into two nested addresses such as in lesson, check for business or personal, add country
[ ] Make form validations for addresses: address 1, city, state, country, zip must be present; zip must be five integers or five plus hyphen plus four integers
[ ] field drop down for USA or all countries if feasible
[ ] Funding_project validation for description must be at least 400 char long, funding_goal must be integer
[ ] code to remove minus symbol when funds still needed
[ ] Make form validations for pledges, must be integer
[ ] Comments validation no more than 400 characters
[ ] add users names to comments on funding projects
[ ] Add custom writer for user to show which pledges are subject to be withdrawn by funding_project creator, when funding goal is 90% met (money isn't withdrawn until funding goal is met)

Finished To Do

[x] For SF_Lit Fanvorites: LitFanAuthor, LitFanWork for has many assoc with nested resources for index and new
[x] Make a static page for All SF Film Fanvorites
[x] set gitignore for temp files 
[x] Add categories model for funding_projects: 
[ X ] Make sure login works
[ x ] Make a nested resource for a user address 
[x] Make admin privleges; only admin can delete a project
[x] Make admin privileges; only admin can change/add/delete funding_project_categories


Questions:
Help with [ ] Get funding_project to instantiate with associated, aliased user at nested route for funding_project#show
[ ] Make nested URL route work for USERS/:ID/SF_favs
Will I need to customize anywhere? (eg., with #new form with routes with nested resources)?
Do I have the right, many to many, relationship with funding projects and users throuh pledges?
  If not could I do it with users, funding_projects, and comments
when do you use a custom writer as opposed to other methods to make associations such as build
can I make USERS/1/SF_favs into a nested resource or do I need to do soomething else?

UNUSED

<h2>For checking out or recommending a specific work, browse through all the works or search for a specific one.

<h3>Go to <%= link_to 'All Works Fanvorites', lit_fan_works_path %></h3>

<h3>Search for a Work: </h3>


<h2>For checking out works and authors by genre, browse through all the genres or search for a specific one.

<h3>Go to <%= link_to 'All Fanvorite Genres', lit_fan_genres_path %></h3>

<h3>Search for a Work: </h3>


    <%= f.label "Find or write the work's title below:" %><br>
    <%= f.text_field :title, list: "lit_fan_works_autocomplete" %>
    <datalist id="lit_fan_works_autocomplete">
    <% LitFanWork.all.each do |lfw| %>
    <option value="<%= lfw.title %>">
    <% end %>
<%# <h4>Choose the author from the list of recommended authors below ... </h4> %>
    <%# <%= lit_fan_author_select(@lit_fan_work.lit_fan_author, @lit_fan_work) %><br><br> 
    <%# <h4>or add a new one ...</h4> %>
<%# However, we've lost the ability for users to create their own categories.
That might be what you want. For example, the content management system for a magazine would probably want to enforce that the category of an article is one of the sections actually printed in the magazine.
In our case, however, we want to give users the flexibility to create a new category or pick an existing one. What we want is autocompletion, which we can get with a datalist:
<%= form_for @post do |f| %>
 <%# <%= f.text_field :category_name, list: "categories_autocomplete" %> %>
 <%# <datalist id="categories_autocomplete"> %>
   <%# <% Category.all.each do |category| %> %>
     <%# <option value="<%= category.name %>"> %>
   <%# <% end %> %>
 <%# </datalist> %>
 <%# <textarea name="post[content]"></textarea> %>
<%# <% end %> %>
<%# datalist is a new element in the HTML5 spec that allows for easy autocomplete. Check below in Resources for further reading. %> %>
# This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rails db:seed command (or created alongside the database with db:setup).
#
# Examples:
#
#   movies = Movie.create([{ name: 'Star Wars' }, { name: 'Lord of the Rings' }])
#   Character.create(name: 'Luke', movie: movies.first)
frank_jones = User.create(name: "Frank Jones", email: "frankjones@yahoo.com", password: "frank jones password")
fantastic_cats = FundingProject.create(creator_name: "Frank J Inc.", title: "Fantastic Cats", description: "A collection of short stories about cats with science fiction and fantasy settings.", funding_goal: 500, user_id: 1)
# frank_jones_cats_pledge = Pledge.create(amount: 10, user_id: 1, funding_project_id: 1)
# frank_jones_address = Address.create(address1: "100 Main Street")
# new_story = LStory.create(title: "b", content: "b")
# new_genre = OGenre.create(name: "b")


 [x] Choose or make a new creator with the new form for new fp 
 [x] funding_project_creator can have different name, other profile info, but will be same :id and login for a user

  # resources :users do
  #   resources :funding_projects, only: [:index, :show, :new, :edit]
  # end
  # resources :funding_projects

  
  # def addresses_index
  #   @user = User.find(params[:id])
  #   @addresses = @user.addresses
  #   render template: 'addresses/index'
  # end
 
  # def post
  #   @user = User.find(params[:id])
  #   @address = Address.find(params[:user_id])
  #   render template: 'addresses/show'
  # end

class FundingProjectsController < ApplicationController
  before_action :require_login
  # skip_before_action :require_login, only: [:index, :show]
  # before_save :make_titlecase

  def index
    @funding_projects = FundingProject.all
    # @user = User.find_by(id: params[:user_id])
    # @funding_projects = @user.funding_projects
  end

  # def comments_index
  #   @funding_project = FundingProject.find(params[:id])
  #   @comments = @funding_project.comments
  #   render template: 'comments/index'
  # end

  # def comment
  #   @funding_project = FundingProject.find(params[:id])
  #   @funding_project.comment.id = Comment.find(params[:id])
  #   render template: 'comments/show'
  # end

  def new
    @funding_project = FundingProject.new

    # @user = User.find(params[:id])
    # @user = User.find_by(id: params[:id])



    # @funding_project.comments.build
    # @funding_project.user_id = current_user
    # @comment = @comment.find_by(:id)
    # @funding_project.id = @comment.fundng_project_id
    # @funding_project.comments.build
  end

  def create
    
    @funding_project = FundingProject.new(funding_project_params)
    @user = User.find_by(id: params[:user_id])
    @funding_project = @user.funding_projects.find_by(id: params[:id])
    
    # @user = User.find(params[:id])
    @funding_project.save

    redirect_to user_funding_project_path(@user, @funding_project)
    # binding.pry


    # @funding_project.fp_creator_id = current_user.id
    # fp = @funding_project
    # fp.save
    # current_user.funding_projects << fp
    # @user.funding_projects << funding_project
    # @funding_project = @user.funding_projects.last
    # binding.pry
    # if @funding_project.valid?

    # raise params.inspect
    # binding.pry
    # @funding_project.fp_creator_id = 
    # @funding_project.fp_creator_id = FpCreator.where(:id == current_user.id)
    # if @funding_project.valid?
      # fp_pledges = @funding_project.pledges
      # @user = User.find_by(id: params[:user_id])

    # @user = current_user
    # @funding_project = @user.funding_projects.last
    # binding.pry
    # redirect_to fp_creator_funding_project_path(@user, @funding_project.id)
    # else
      # funding_project_path(@funding_project)
    # else
    #   render :new
    # end
    end

  def show
    @user = User.find_by(id: params[:user_id])
    @funding_project = @user.funding_projects.find_by(id: params[:id])
    # @funding_project = FundingProject.find(params[:id])
    # NOTE: Above doesn't work because there needs to be an association in the first place, not finding a funding_project
    @total_pledges = []
    # @comments = Comment.where(:funding_project_id == @funding_project.id)
  end

  def edit
    #make editong an already made FP instance possible
  end

  def update
    #update an already made FP instance, including saving it
  end

  def destroy
  end

  private

  def funding_project_params
    params.require(:funding_project).permit(
      :creator_name,
      :fp_participant_id,
      :fp_creator_id,
      # :funding_project_pledge,
      :title,
      :description, 
      :funding_goal, 
      # comments_attributes: [:title, :content]
      :user_id)
  end

  # def fp_creator_params
  #   params.require(:fp_creator).permit(
  #     "name",
  #     "location",
  #     "name_of_verified",
  #     "verified?",
  #     "creator_profile",
  #     "last_logged_in",
  #     "fp_amt_created",
  #     "fp_amt_backed",
  #     "creator_site",
  #     "instagram_url",
  #     "twitter_url",
  #     "facebook_url",
  #     "blog_url",
  #     "user_id",
  #     funding_projects_attributes: [:title, :description, :funding_goal]
  #   )
  # end


  def require_login
    unless logged_in?
      flash[:alert] = "You must be logged in to access this section"
      redirect_to login_url
    end
  end


#   def total_pledges
#     self.pledges.each do |p| 
#        p.amount  
#     end
# end

end
[ ] Making living story feature, to include OpenGenre feature, with OpenGenres to be nested under Living Story
l_story_1 = LStory.new(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genre_id => 1, :ls_genre_attributes => {:id => 1, :name => "Fantasy"})
l_story_2 = LStory.create(:title => "My Second Living Story", :content => "It was a dark but not as stormy morning ...",
l_story_1 = LStory.create(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genres_attributes => {:id => 1})

=> #<OGenre id: 1, name: "Fantasy", user_id: nil, l_story_id: nil, created_at: "2018-07-28 16:57:36", updated_at: "2018-07-28 16:57:36">
2.3.3 :003 > l_story_1 = LStory.create(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genre_attributes => {:id => 2, :name => "Horrible Horror"})
ActiveModel::UnknownAttributeError: unknown attribute 'o_genre_attributes' for LStory.
        from (irb):3
2.3.3 :004 > l_story_1 = LStory.create(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genres_attributes => {:id => 2, :name => "Horrible Horror"})
ActiveRecord::RecordNotFound: Couldn't find OGenre with ID=2 for LStory with ID=
        from (irb):4
2.3.3 :005 > l_story_1 = LStory.create(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genres_attributes => {:id => 1})
ActiveRecord::RecordNotFound: Couldn't find OGenre with ID=1 for LStory with ID=
        from (irb):5
2.3.3 :006 > l_story_2 = LStory.create(:title => "My Second Living Story", :content => "It was a dark but not as stormy m


<%= f.label "Name of Sponsoring Individual or Organization (Creator) "%>
<%= f.text_field :name %><br>
<%= f.label "Location "%>
<%= f.text_field :location %><br>
<%= f.label "Name of Verified for Project "%>
<%= f.text_field "name_of_verified" %><br>
<%= f.label "About Creator "%>
<%= f.text_area "creator_about" %><br>
<%= f.label "Creator Website "%>
<%= f.text_field "creator_site" %><br>
<%= f.label "Instagram "%>
<%= f.text_field "instagram_url" %><br>
<%= f.label "Twitter "%>
<%= f.text_field "twitter_url" %><br>
<%= f.label "Facebook "%>
<%= f.text_field "facebook_url" %><br>
<%= f.label "Blog "%>
<%= f.text_field "blog_url" %><br>
<%= f.submit %>
<% end %>

<h1>Creator Profile for <%= @fp_creator.name %></h1><br>
<h3>Connected to User <%= @current_user.name %></h3>

<p>Name: <%= @fp_creator.name %></p>
<p>Location: <%= @fp_creator.location %>
<p>Name of Verified: <%= @fp_creator.name_of_verified %>
<p>About Creator: <%= @fp_creator.creator_about %>
<p>Creator Website: <%= @fp_creator.creator_site %>
<p>Creator Instagram: <%= @fp_creator.instagram_url %>
<p>Creator Twitter:<%= @fp_creator.twitter_url %>
<p>Creator Facebook:<%= @fp_creator.facebook_url %>
<p>Creator Blog: <%= @fp_creator.blog_url %><br><br>

<h2><%= link_to "Make a New Sourcer Project for this Creator", new_funding_project_path %> </h2><br>

<h3>Edit Profile</h3>

class AdminController < ApplicationController
  before_action :require_admin

  def require_admin
    unless current_user.admin?
      redirect_to root_path
    end
  end
end
Now, each namespaced admin controller can inherit directly (and quite appropriately) from AdminController. Since weâ€™ve defined the before_action in AdminController, actions in any sub-classed controller will be restricted to admin users by default.

We no longer need to list the before_action or define a require_admin method in each of our namespaced controllers; they just inherit from AdminController:

class Admin::CategoriesController < AdminController
  # Methods omitted
end





Unused Code:

class CreateJoinTable < ActiveRecord::Migration[5.2]
  def change
    create_join_table :fp_creators, :funding_projects do |t|
      # t.index [:fp_creator_id, :funding_project_id]
      # t.index [:funding_project_id, :fp_creator_id]
    end
  end
end

<!DOCTYPE html>
<html>
  <head>
    <title>RailsAmusementPark</title>
    <%= csrf_meta_tags %>

    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        <a class="navbar-brand" href="<%= root_url %>"/>Home</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <% if current_user %>
              <li><%= link_to "Hello, #{current_user.name}!", user_path(current_user) %></li>
              <li><%= link_to "Attractions", attractions_path %></li>
              <li><%= link_to "Log Out", signout_path, method: :delete %></li>
            <% else %>
              <li><%= link_to "Sign Up", new_user_path %></li>
              <li><%= link_to "Sign In", signin_path %></li>
            <% end %>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <!-- content -->
    <div class="container"  role="main">
      <%= yield %>
    </div>
  </body>
</html>

  <h3>Make a Comment About This Project!</h4>
<%= form_for :comment, action: :new, url: 'new_comment_path' do |f| %>
<%= f.label :title %>
<%= f.text_field :title %><br>
<%= f.label "What do you think?" %>
<%= f.text_area :content %><br>
<%= f.submit "Submit"%>
<% end %>

# get 'addresses/index'
  # get 'addresses/new'
  # get 'addresses/create'
  # get 'addresses/show'
  # get 'addresses/edit'
  # get 'addresses/update'
  # get 'addresses/destroy'

  # resources :funding_projects do 
  #   resources :fp_comments
  # end

  #can only destroy a funding project as admin

  # get 'pledges/new'
  # get 'pledges/create'
  # get 'pledges/show'
  # get 'pledges/edit'
  # get 'pledges/update'
  # get 'pledges/destroy'
  # get 'funding_projects/index'
  # get 'funding_projects/new'
  # get 'funding_projects/create'
  # get 'funding_projects/show'
  # get 'funding_projects/edit'
  # get 'funding_projects/update'
  # get 'funding_projects/destroy'
  # get 'users/index'
  # get 'users/new'
  # get 'users/create'
  # get 'users/show'
  # get 'users/edit'
  # get 'users/update'
  # get 'users/destroy'


               # oauth_email = request.env["omniauth.auth"][:info][:email]
            #     session[:user_id] = user.id
            #     redirect_to root_path
            # else 
            #     user = User.new(:email => oauth_email, :password = SecureRandom.hex)
            # if user.save
            #     session[:user_id] = user.id
            # else
            #     raise user.errors.full_messages.inspect

         # new_user_pledge = User.where(:id == @pledge.user_id)
    # @pledge.user_id = new_user_pledge    

    
    
    # @pledge = Pledge.where(:funding_project_id == @funding_project.id)
    # pledge = Pledge.create(params[:amount])
    # @funding_project.pledges < pledge

   # def create
#   @user = User.find_or_create_by(uid: auth['uid']) do |u|
#     u.name = auth['info']['name']
#     u.email = auth['info']['email']
#     u.image = auth['info']['image']
#   end

#   session[:user_id] = @user.id

#   render 'welcome/home'
# end

# private

# def auth
#   request.env['omniauth.auth']
# end

# <% if session[:user_id] %>
#   <h1><%= @user.name %></h1>
#   <h2>Email: <%= @user.email %></h2>
#   <h2>Facebook UID: <%= @user.uid %></h2>
#   <img src="<%= @user.image %>">
# <% else %>
#   <%= link_to('Log in with Facebook!', '/auth/facebook') %>
# <% end %>


    current_funding_project = FundingProject.where(@pledge.user_id == current_user)
binding.pry
    project_pledges = current_funding_project.pledges 

    new_pledge_save = @pledge 
    
    project_pledges << new_pledge_save 

    @pledge = new_pledge_save



<h2>Make a pledge for this project:</h2><br>
<%= form_for @funding_project do |f| %>
<h4>Pledge Amount (in U.S. dollars) <%= f.text_field :funding_project_pledge %></h4>
<%= f.submit "Make a Pledge"%>
<% end %>

<%# <p>Amount Pledged: <%= @funding_project.funding_goal %> </p><br> %>

<%# if @pledge.user_id == @funding_project.id %>
<%# make a form that lets you pledge right there
set @pledge form for
text_box for amount
makes use of @funding_project --- hidden param?
    or make it a collection nested hash
user_id assocation is easy, from sessions
direct to pledges#show %>

<%= form_for(@pledge) do |f| %> %>
<%# <%= @funding_project.id = @pledge.funding_project_id %> %>
<%= f.text_field :amount %>
<%= f.hidden :funding_project_id %>
<%= f.submit "Make a Pledge"%>
<% end %>



<%# <h2><%= link_to "Click here to make a pledge for this project (in U.S. dollars)", new_pledge_path %></h2><br> %>
<%# <%= form_for @funding_project do |f| %> %>
<%# <h4>Pledge Amount  <%= f.text_field :amount %></h4> %>
<%# <%= f.submit "Make a Pledge"%> %>
<%# <% end %> %>




<%# <%= link_to '/pledges/new', pledges_path%> %>


