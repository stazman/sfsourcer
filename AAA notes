
TO DO:

l_stories feature:
  creates final submit button to go to actionable story
  adds index view and 
  allows editing of new story beginning on new view
  
wg_works feature:
  finish writer's groups/wg_works association
  add js functionality to wg_works for a writer_group:
    all wg_works
    next button

fanvorites feature:
  renders new fanvorite author, genre, work in new view for preview before submitting (needed because already has edit function?)
    using a class constructor
  allows editing of new author, genre, work in new view (needed because already has edit function)


  


FUTURE TO DO: 

  Rails/HTML/CSS/content

    Add news/events, related articles to fanvorites show views sidenavs
    
    fix nested params for fpcreators on funding project show view
    
    Create MVC for new events

    Have Fanvorites nested routes use partial for heading navbar

    Make test for navbar

    Have sidenavs collapse/be relocated responsively on small screen sizes

    Standardize page style across all pages

    Clean up/reogranize landing pages
      Fanvorites
      LStories
      Funding Project index and new

    Home page: https://stackoverflow.com/questions/38901166/horizontal-scrollable-divs-in-a-bootstrap-row
      Add feature descriptions to home page feature boxes
      Add images, style and effects
      Clean up container margins


JS

  Use JS to remove place to make/choose name after finished

  Build holding place in line to write functionality

  Add comments section to fanvorites show views


[ ] Get funding_project to instantiate with associated, aliased user at nested route for funding_project#show
[ ] Check into gems that let you integrate Thirdparty authentication into own authentication; could try separate signup and only FB login, but seems unsophisticated
[ ] fix new lit_fan_author instantiation issue
[ ] fix blank instance issue for genres collection/new genre field
[ ] apply what learning in js/jquery section to the project
[ ] make your next branch/track for git remotely
[ ] correct sf_favs to allow all combinations of blank/filled out fan fanvorites
[ ] make class method? involving pledges and funding project
[ ] Make FpBacker instantiate with Pledges correctly
[ ] connect distinct, remotely connected roles to user
[ ] for the next feature, use git branching
[ ] right now you need to be a registered user to make a pledge; needs to be doable without registering ... kickstarter doing guest pledging now
    [ ] use one of several available gems for giving user multiple roles ?!!! or learn a more up to date? and systematic authorization/authentication system (check bookmarks)
[ ] Make separate model for fp_commenter to comment on funding_projects and be associated with user
[ ] reverse what model nests the other model for funding_project/fp_creator?
[ ] Complete #ready_for_countdown class method 
[ ] Complete #ready_for_countdown class method 
[ ] Add spaces between checkbox choices in authors index view
[ ] Make links to all works and genres as well as all authors
[ ] Make links to all works and genres as well as all authors
[ ] Make Fanvorite static pages for literature, film, and games
[ ] Make new fan pages based on author, title, and genre links in All SF Fanvorites
[ ] Make created fan pages based on author, title, and genre links in sections for All SF Fanvorite formats
[ ] Try to persist address
[ ] Refactor pledge amount logic in funding_project#show?
[ ] make living story feature where a user is both a ls_creator and a ls_participant, ls_creator creates it and ls_partipant adds to it through comments but they're directly below the creator's original beginning ... which user is typing will be at the side ... if it's a free for all that might be part of the fun ... make a contest with decent prizes 
[ ] include remaining attributes for fp_creator to new funding_project or make a separate model/interface
[ ] Use aliases for other relationships (comment, categories, etc.)
[ ] getting funding_project#show to include a new form for making a comment associated with the project
[ ] Nest funding_project_categories under funding_project
[ ] Add how many days to go and how many backers for funding_project
[ ] Give funding_project_creator choice to be same as user for login or not?
[ ] Make funding_project category a nested attribute to choose when making a new funding_project
[ ] Make new funding_project only possible with admin login
[ ] category a nested attribute to choose when making a new funding_project
[ ] Make index of users only available with admin login
[ ] Make landing pages for all sections
[ ] Finish comments feature for projects
[ ] Refactor to include navbar: Your Profile
[ ] add authentication for admin ... make admin controller in controllers/admin but figure out authentication Monban; https://roberteshleman.com/blog/2014/08/14/using-rails-namespaces-for-admin-actions/
[ ] refactor for Model.find
[ ] Add JS snippet to prevent backsies
[ ] add feature: Which number of project it is for a user is :experience attribute to be a feature mostly connected to funding_project model
[ ] add last time logged in for project creators
[ ] Make a class scope method for all funding_projects that have met 80% funding
[ ] Make a custom route for countdown_projects
[ ] Change name into first name middle name last name entries ... nest them perhaps
[ ] Make form validations for user: must have first and last name, email must match best regex I can find, password must have at least one capital letter, 1 number, and 1 symbol and be 8 characters login
[ ] Change address into two nested addresses such as in lesson, check for business or personal, add country
[ ] Make form validations for addresses: address 1, city, state, country, zip must be present; zip must be five integers or five plus hyphen plus four integers
[ ] field drop down for USA or all countries if feasible
[ ] Funding_project validation for description must be at least 400 char long, funding_goal must be integer
[ ] code to remove minus symbol when funds still needed
[ ] Make form validations for pledges, must be integer
[ ] Comments validation no more than 400 characters
[ ] add users names to comments on funding projects
[ ] Add custom writer for user to show which pledges are subject to be withdrawn by funding_project creator, when funding goal is 90% met (money isn't withdrawn until funding goal is met)








***************************** RAILS/JS PROJECT FINISHED TASKS ******************************


[x] Finish out unwritten CRUD actions
[x] Clean up all code for submission
[x] video runthrough
[x] blog
[x] Add error message for not being logged in to making an author, litfanwork, or genre
[x] For all relevant views: fields should be enclosed within a fields_with_errors class and error messages describing the validation failures must be present within the view on all relevant views
[x] Add more validations important for security
[x] Make sure all validations work
[x] Make sure all relevant controllers have login requirement for fanvorites feature
[x] make sure Facebook signup works
[x] require login for all pages for now
[x] For SF_Lit Fanvorites:  LitFanGenre Make genre model for has many assoc with title and has many through with author
[x] For SF_Lit Fanvorites: LitFanAuthor, LitFanWork for has many assoc with nested resources for index and new
[x] Make a static page for All SF Film Fanvorites
[x] set gitignore for temp files 
[x] Add categories model for funding_projects: 
[ X ] Make sure login works
[ x ] Make a nested resource for a user address 
[x] Make admin privleges; only admin can delete a project
[x] Make admin privileges; only admin can change/add/delete funding_project_categories

Project Repo Specs:
Read Me file contains:

DONE 9 * Application Description

DONE 10 * Installation guide (e.g. fork and clone repo, migrate db, bundle install, etc)

DONE 11 * Contributors guide (e.g. file an issue, file an issue with a pull request, etc)

DONE 12 * Licensing statement at the bottom (e.g. This project has been licensed under the MIT open source license.)


Repo General
DONE * You have a large number of small Git commits
DONE * Your commit messages are meaningful
DONE * You made the changes in a commit that relate to the commit message
DONE * You don't include changes in a commit that aren't related to the commit message

DONE 7 * Must use your Rails application to render a form for creating a resource that is submitted dynamically through JavaScript. WRITER_GROUPS#CREATE
DONE 6 * Your Rails application must reveal at least one `has-many` relationship through JSON that is then rendered to the page. WG_WORKS/WG_COMMENTS ON FUNG_PROJECT#SHOW
WG_WORKS/WG_COMMENTS ON WG_WORKS INDEX VIEW

DONE pledges index view should show all pledges
DONE pledges index controller should have html and json formats
DONE funding_project#show should show results of button click by adding lines to ul
DONE accesses pledges for the specific funding_project

DONE writer_group js issue
  DONE check that js is working in asset pipeline


DONE Make sure wg_works working through rails only
DONE Make sure wg_comments working through rails only

DONE Add links for wg_writer_group titles on wg_works index page to show page for each work -- 5 R/JS Project requirement

DONE Add wg_creator to rendered list of groups on writer_group_home via AMS -- 4 R/JS Project requirement

Fix alert not working:
DONE  Check turbolinks reloading action 
DONE  Check if Ajax issues 
  

Finish setting up and filling out:
DONE  Clean up/reorganize home page 
DONE  Add template for landing page for funding-project section 
DONE    Fill out 
DONE    Fix links 
DONE  Add template for lstories show page 
DONE    Fill out 
DONE  Make Navbar standard on all pages 
DONE    add dropdowns 
DONE  Fix existing links for all of these 
DONE  Add Events page and route 
DONE    build landing page views for fanvorites 
DONE  Add partial for navbar to layouts 

  
***************************** NOTES ******************************


polymorphic with pledges? doesn't seem to fit

add function for each user to be "up" and claim the spot (with a time limit) and be able to add a line without being interrupted

add <p>New user? <%= link_to "Sign up now!", signup_path %></p>to login page





***************************** UNUSED CODE ******************************

l_stories controller


  
  # def edit
  #   @ls_comment = LsComment.find_by(params[:id])
  # end

  # def update
  #   @ls_comment = LsComment.find_by(params[:id])
  #   @ls_comment.save
  #   redirect_to l_story_path(@ls_comment)
  # end


funding_projects index view

  
      //   dataArray.forEach(function(element, index, array) {
      //     console.log(element.amount); // 100, 200, 300
      //     debugger
      //     console.log(index); // 0, 1, 2
      //     console.log(array); // same myArray object 3 times
      // });
        // var myMap = new Map(data);
        // debugger

        // myMap.get("amount")

          // data.map(function(pledge){ 
          //   debugger

          //   var pledgeKey = []
          //   pledgeKey[pledge] = pledge.value
          //   for (const nestedKey in pledgeKey) {
          //     debugger
          //       return pledgeKey[nestedKey];
          //   }

          // return pledge.amount                                    

            // var rObj = {};
            // debugger
            // rObj[obj.amount] = obj.value;
            //   debugger

        // var arr = [
        //   { id: 15 },
        //   { id: -1 },
        //   { id: 0 },
        //   { id: 3 },
        //   { id: 12.2 },
        //   { },
        //   { id: null },
        //   { id: NaN },
        //   { id: 'undefined' }
        // ];
        
        // var invalidEntries = 0;
        
        // function isNumber(obj) {
        //   return obj !== undefined && typeof(obj) === 'number' && !isNaN(obj);
        // }
        
        // function filterByID(item) {
        //   if (isNumber(item.id) && item.id !== 0) {
        //     return true;
        //   } 
        //   invalidEntries++;
        //   return false; 
        // }
        
        // var arrByID = arr.filter(filterByID);
        
        // forEach(function(fp_pledge){
        //   debugger

        //   if (fp_pledge.amount === fp_pledge.amount.max){
            
        //   $result.append(fp_pledge.amount);
        //   }
        // })

        // let fpPledges = data;
          // const digDeep = function  (data) {
          //   for (const key in data) {
          //     if (typeof data[key] === 'object') {
          //       for (const nestedKey in data[key]) {
          //         return data[key][nestedKey];
        
          //       }
          //       debugger
          //     } else {
          //       console.log(target[key]);
          //     }
          //   }
          // })
          // $("#largest_pledge").text(digDeep.amount);             
            // filter( pledge => pledge.amount === 20)




users show view


<%# <h3>Living Stories You Have Contributed To:</h3>
<% @user.l_stories.each do |ls| %>
<%# <%= link_to p.title, l_story_path(ls) %>
<%# <% end %>

<%# <h3>Check out our Sourcer Projects!</h3> %>
<%# <h4><%= link_to "Sourcer Projects Page", "/sourcer_projects" %>

<%# <h3>Or make your own project!</h3> %>
<%# <h4><%= link_to "Make a New Sourcer Project", new_funding_project_path %>

<%# <h3>Check out our fabulous features!</h3> %>
<%# <h4><%= link_to "Living Story Page", "/living_stories" %>



funding_projects index view

<%# <h2>Browse SFSourcer Projects Nearing Final Countdown: </h2> %>
<%# <h3><%= link_to "5..4..3..2...", ready_for_countdown_funding_project_path %>

<%# <h2>Browse SFSourcer Projects Nearing Final Countdown: </h2> %>
<%# <h3><%= link_to "5..4..3..2...", ready_for_countdown_funding_project_path %>


      <%
=begin%>
 <p><h5>Creator Profile</p><br>
      <% @funding_project.fp_creators.each do |fpc| %>
    <ul>
        <p>Creator: <li><%= fpc.creator_name %></li></p><br><br>
        <li>Location: <%= fpc.location %></li><br><br>
        <li>About Creator: <%= fpc.creator_about %></li><br><br>
        <li>Creator Website: <%= fpc.creator_site %></li><br><br>
        <li>Email: <%= fpc.email %></li><br><br>
        <li>Creator Instagram: <%= fpc.instagram_url %></li><br><br>
        <li>Creator Twitter:<%= fpc.twitter_url %></li><br><br>
        <li>Creator Facebook:<%= fpc.facebook_url %></li><br><br>
        <li>Creator Blog: <%= fpc.blog_url %></li>
    </ul>
<% end %><br><br> 
<%
=end%>


      <div>
        <button id="all_pledges">Click Here to See All Individual Pledge Amounts</button>
      </div>
      <br>
      <div class="fpPledges">
        <ul>
          
        </ul>
      </div>



// $(function () {
//   $("#all_pledges").on('click', function(e) {
    
//     let $ul = $("div.fpPledges ul");

//     $ul.html = "";

//     let id = $(this).data("id");


//     $.get("/funding_projects/" + id + "/pledges", function(){
//         json.forEach(function(pledge){
//         $ul.append("<li>" + pledge.amount + "</li>");
//       });
//     });
//     e.preventDefault();
//   });
// });


   <head>
      <%= javascript_include_tag 'writer_groups'  %>
   </head>

<h1><%= @writer_group.wg_name %></h1>

<p>Group Creator: <%= @writer_group.wg_creator %></p>
<br><br>
<p>Group Description: <%= @writer_group.wg_description %>
</html>



    <ul>
        <% @wg_work.wg_comments.each do |wgw| %>
        <p><li>Critique/Comment: <%= wgw.content %></li></p>
        <br>
        <p><li>Commenter: <%= wgw.author %></p></li>
        <br><br>
    </ul>
        <% end %>

// 

//               json object must be accessed
//               need to access id of funding project from json object
//                need to access pledges
//                  need to access id and amount of each pledge associated with the funding_project
//                  needs to render associated funding_project and pledges in a list on the funding_project 
//                      in the list provided below the link event



//  $("a.all_pledges").on("click", function(e){
//   $.get(this.href).success(function(json){

//     let $ul = $("div.fpPledges ul")


// //              needs to access pledges for the funding_project from json object

//   let $ul = $(this).data
//   $ul.html("");
//   json.forEach(function(funding_project, pledge){
//       $ul.append("<li>" + "<a " + "href='" + "/funding_projects/" + funding_project.id + "/pledges/" + "</a>" + "</li>");
//       // + pledge.id + "' >" + pledge.amount
//         });
//     });
//     e.preventDefault();
// })
// })


// $(document).ready(function() {
//   $("#text").append("this is a test.");
// });

// $(function () {
//     $(".js-more").on('click', function() {
//       let id = $(this).data("id");
//       $.get("/funding_projects/", function(data) {
//         // Replace text of body-id div
//         $("#description-" + id).text(data);
//       });
//     });
//   });


// $('a.load_fps').on('click', function(e) {
//     alert("Here are all the projects!");
//     e.preventDefault();
// })

// $(function () {
//   $(".js-more").on('click', function() {
//     // get the id from the data attribute
//     let id = $(this).data("id");
//     $.get("/funding_projects/" + id + "/body", function(data) {
//       alert(data);
//     });
//   });
// });

// $(function(){
//   $("form#new_funding_project").on("submit", function(e){
//     alert("You've created a new project!");
//     e.preventDefault();

//     let $form = $(this);
//     let action = $form.attr("action");
//     let params = $form.serialize()

//     $.post(action, params)
//     // console.log("A Project is Born!");
//   })
// })


// $(function(){

  //         // event handler
  
  //   $("a.all_pledges").on("click", function(e){
  //     $.get(this.href).success(function(json){
  
  //       let $ul = $("div.fpPledges ul")
  
  
  // //              needs to access pledges for the funding_project from json object
  
  //     let $ul = $(this).data
  //     $ul.html("");
  //     json.forEach(function(funding_project, pledge){
  //         $ul.append("<li>" + "<a " + "href='" + "/funding_projects/" + funding_project.id + "/pledges/" + "</a>" + "</li>");
  //         // + pledge.id + "' >" + pledge.amount
  //           });
  //       });
  //       e.preventDefault();
  //   })
  // })



$(function(){
    $("a.load_writer_groups").on("click", function(e){
        // alert("This is a test");
        $.get(this.href).success(function(json){
            // console.log(data);
            // $("body").append(data);
            // $("div.writer_groups.ul").
            let $ul = $("div.writer_groups ul")

            $ul.html("");

            json.forEach(function(writer_group){
                $ul.append("<li>" + "<a " + "href='" + "/writer_groups/" + writer_group.id + "' >" + writer_group.wg_name + "</a>" + " - " + writer_group.wg_creator + "</li>");
            });
        });
        e.preventDefault();
    })
})
<% @wg_works.each do |wgw| %>

<%= wgw.title %><%>
<% end %>


            <p><%= link_to @funding_projects[5].title, funding_project_path(@funding_projects[5]) %></p> 

            <button onclick="myFunction()">About this project ...</button>
        <br>
        <div class="panel-body"><img src="https://placehold.it/150x80?text=IMAGE" class="img-responsive" style="width:100%" alt="Image"></div>
      </div>
    </div>
    <div class="col-sm-5"> 
      <div class="panel panel-primary">
        <div class="panel-body">
            <p><% @funding_projects.each do |fp| %></p>
                <h4><%= link_to fp.title, funding_project_path(fp) if fp == @funding_projects[1] %></h4>
                <%
=begin%>
 <div><%= truncate @funding_projects[1].description %></div>
                <button class="js-more" data-id="<%= @funding_projects[1].id %>">More...</button> 
<%
=end%>
                <% end %>
        </div>
        <br>
        <div class="panel-body"><img src="https://placehold.it/150x80?text=IMAGE" class="img-responsive" style="width:100%" alt="Image"></div>
      </div>
    </div>



<div class="text-center .mx-auto px-{2}">
  <div class="stripe_row">
    <div class="col-sm-10">
      <div><p><strong>Almost Funded</strong></p></div>
  </div>
</div>

<div class="container">
    <div class="col-sm-5">
      <div class="panel panel-primary">
        <div class="panel-body">
            <p><% @funding_projects.each do |fp| %></p>
              <ul>
                <h4><%= link_to fp.title, funding_project_path(fp) if fp == @funding_projects[0] %></h4>
                 <button class="more">More...</button> 
              </ul>
                <% end %>
        </div>
        <br>
        <div class="panel-body"><img src="https://placehold.it/150x80?text=IMAGE" class="img-responsive" style="width:100%" alt="Image"></div>
      </div>
    </div>
    <div class="col-sm-5"> 
      <div class="panel panel-primary">
        <div class="panel-body">
            <p><% @funding_projects.each do |fp| %></p>
              <ul>
                <h4><%= link_to fp.title, funding_project_path(fp) if fp == @funding_projects[1] %></h4>
                <%
=begin%>
 <div><%= truncate @funding_projects[1].description %></div> 
<%
=end%>
                <%
=begin%>
 <button class="js-more" data-id="<%= @funding_projects[1].id %>">More...</button> 
<%
=end%>

              </ul>
                <% end %>
        </div>
        <br>
        <div class="panel-body"><img src="https://placehold.it/150x80?text=IMAGE" class="img-responsive" style="width:100%" alt="Image"></div>
      </div>
    </div>

<div class="text-center .mx-auto px-{2}">
  <div class="stripe_row">
    <div class="col-sm-10">
      <div><p><strong>Newest Projects</strong></p></div>
  </div>
</div>
    <div class="col-sm-5">
      <div class="panel panel-primary">
        <div class="panel-body">
            <p><% @newest_fps_first.each do |fp| %></p>
              <ul>
                <h4><%= link_to fp.title, funding_project_path(fp) if fp == @newest_fps_first[0] %></h4>
                <%
=begin%>
 <div><%= truncate @newest_fps_first[0].description %></div>
                <button class="js-more" data-id="<%= @newest_fps_first[0].id %>">More...</button> 
<%
=end%>
              </ul>
                <% end %>
        </div>
        <br>
        <div class="panel-body"><img src="https://placehold.it/150x80?text=IMAGE" class="img-responsive" style="width:100%" alt="Image"></div>
      </div>
    </div>
    <div class="col-sm-5">
      <div class="panel panel-primary">
        <div class="panel-body">
            <p><% @newest_fps_first.each do |fp| %></p>
              <ul>
                <h4><%= link_to fp.title, funding_project_path(fp) if fp == @newest_fps_first[1] %></h4>
                <%
=begin%>
 <div><%= truncate @funding_projects[1].description %></div> 
<%
=end%>
                <%
=begin%>
 <button class="js-more" data-id="<%= @funding_projects[1].id %>">More...</button> 
<%
=end%>
              </ul>
                <% end %>
        </div>
        <br>
        <div class="panel-body"><img src="https://placehold.it/150x80?text=IMAGE" class="img-responsive" style="width:100%" alt="Image"></div>
      </div>
    </div>

<div class="text-center .mx-auto px-{2}">
  <div class="stripe_row">
    <div class="col-sm-10">
      <div><p><strong>Newest Projects</strong></p></div>
  </div>
</div>
    <div class="col-sm-5">
      <div class="panel panel-primary">
        <div class="panel-body">
            <p><% @newest_fps_first.each do |fp| %></p>
              <ul>
                <h4><%= link_to fp.title, funding_project_path(fp) if fp == @newest_fps_first[0] %></h4>
                <%
=begin%>
 <div><%= truncate @newest_fps_first[0].description %></div>
                <button class="js-more" data-id="<%= @newest_fps_first[0].id %>">More...</button> 
<%
=end%>
              </ul>
                <% end %>
        </div>
        <br>
        <div class="panel-body"><img src="https://placehold.it/150x80?text=IMAGE" class="img-responsive" style="width:100%" alt="Image"></div>
      </div>
    </div>
    <div class="col-sm-5">
      <div class="panel panel-primary">
        <div class="panel-body">
            <p><% @newest_fps_first.each do |fp| %></p>
              <ul>
                <h4><%= link_to fp.title, funding_project_path(fp) if fp == @newest_fps_first[1] %></h4>
                <%
=begin%>
 <div><%= truncate @funding_projects[1].description %></div> 
<%
=end%>
                <%
=begin%>
 <button class="js-more" data-id="<%= @funding_projects[1].id %>">More...</button> 
<%
=end%>
              </ul>
                <% end %>
        </div>
        <br>
        <div class="panel-body"><img src="https://placehold.it/150x80?text=IMAGE" class="img-responsive" style="width:100%" alt="Image"></div>
      </div>
    </div>






      <% @l_stories.each do |l| %>
      <ul>
        <li><strong><%= link_to l.title, to: l_stories_path(l) %></strong></li>
        <li>"<%= link_to l.content, to: l_stories_path(l) %>..."</li></p><br><br>
        <% end %>
      </ul>

<head>
  <title>Bootstrap Example</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <style>
    /* Remove the navbar's default margin-bottom and rounded borders */ 
    .navbar {
      margin-bottom: 0;
      border-radius: 0;
    }
    
    /* Set height of the grid so .sidenav can be 100% (adjust as needed) */
    .row.content {height: 450px}
    
    /* Set gray background color and 100% height */
    .sidenav {
      padding-top: 20px;
      background-color: #f1f1f1;
      height: 100%;
    }
    
    /* Set black background color, white text and some padding */
    footer {
      background-color: #555;
      color: white;
      padding: 15px;
    }
    
    /* On small screens, set height to 'auto' for sidenav and grid */
    @media screen and (max-width: 767px) {
      .sidenav {
        height: auto;
        padding: 15px;
      }
      .row.content {height:auto;} 
    }
  </style>


<h3>Welcome to SFSourcer, where we help you experience, support, and create adventures in speculative fiction, all in a community of shared interests!</h3>

<h3>Check out our features below, then sign up to be a member <%= link_to "here", new_user_path %> or <%= link_to "through Facebook", '/auth/facebook' %>!</h3><br>


<h4>Sourcer Projects</h4>

<h4>In our Sourcer Projects section, check out projects in need of funding by our members, or create your own!</h4>

<h4>(Under construction)</h4><br><br>


<h3>In our Fanvorites section, check out members' favorite works of speculative fiction and their authors, as well as films and games with a science fiction, fantasy, or horror theme!</h3>

<h4> <%= link_to "All SF Fanvorites", '/all_sf_fanvorites' %></h4><br><br>


<h3>In our Living Stories section, create a story beginning or join other SFSourcer members in developing a fun and fantastic work of fiction! The ones who make the best story according to a poll of members will be featured in a special section of SFSourcer!</h3>

<h4><%= link_to "All Living Stories", l_stories_path %></h4>
<h4><%= link_to "Start a New Living Story", new_l_story_path %></h4>




FEATURE SECTION

FEATURE SECTION
ClubSites (group discussion boards/chat rooms to be linked with Fanvorites)
<br>
<br>

FEATURE SECTION
YourPages (pages devoted to your own interests, webpages for which you can receive part of ad revenue based on clicks)
<br>
<br>

FEATURE SECTION 
Writer's Groups (where you can have your work read by professionals for a cost, on a one on one or group setting, as well as free discussion and free, non-mentored groups)
<br>
<br>

FEATURE SECTION
Events in Fandom (also linked to Fanvorites)
<br>
<br>

FEATURE SECTION
Special Projects
<br>
<br>

    # has_many :user_fp_creators
    # has_many :users, through: :user_fp_creators
# this may be more appropriate for fp_creators than fp_backers to have a has many through because fp_creators can have multiple users


    # belongs_to :user_fp_creators
    # has_many :funding_projects
    # def funding_project_attributes=(funding_project_attributes)
    #     funding_project_attributes.values.each do |fp_attribute|
    #     fp = FpProject.find_or_create_by(fp_attribute) 
    #     self.funding_projects << fp
    #     end 
    # end

    # def fpc_user_name
    #     self.try(:user).try(:name)
    # end
    # but how does this work from just the parameters??? what mechanism takes what instance through the strong params and how does it do it?
    # def fpc_user_name=(name)
    #     fpc_user = User.find_by(name: name)
    #     # a different parameter than name here?
    #     self.fpc_user = fpc_user
    # end

      # binding.pry
      # if user && user.authenticate(params[:session][:password])      
      # @user = User.find_by(id: params[:id])
        # @user = user.try(:authenticate, params[:sessions][:password])
      # user = User.find_by(params[:email])
      # user && user.authenticate(params[:password])

<% if session[:user_id] %>
  <h1><%= @user.name %></h1>
  <h2>Email: <%= @user.email %></h2>
  <h2>Facebook UID: <%= @user.uid %></h2>
  <img src="<%= @user.image %>">
<% else %>
  <%= link_to('Sign in with Facebook', '/auth/facebook') %>
<% end %>

<%# <h3>Genre/s: <% @l_story.o_genres.each do |og| %>
<%# <%= og.name %>
<%# <% end %>
<%# @l_story.o_genre %>

<%# <% @l_story.ls_comments.each do |c| %>
    <%# <%= c.user.name%>
    <%# <%= c.content %>
<%# <% end %>
 <%# %>

<%# <% @l_story.users.uniq.each do |u|%>
<%# user_path(u) worked because I passed in the whole object as a parameter %>
<%# <% end %>

    <%# <label>Choose Your Profile Name ... </label><br><br> %>
    <%# <%= f.collection_select :user_id, User.all, :id, :username %><br><br><br> 
    <%# <%= f.label "Or Make a New Profile" %><br>
    <%# <%= f.fields_for :user, @user do |lsc_user|%>
        <%# <%= lsc_user.text_field :name %>
    <%# <% end %>

class User < ActiveRecord::Base
  has_many :ls_comments
  has_many :l_stories, through: :ls_comments
end

class LsComment < ActiveRecord::Base
  belongs_to :user
  belongs_to :l_story
end

class LStory < ActiveRecord::Base
  has_many :ls_comments
  has_many :users, through: :ls_comments
end

class UsersController < ApplicationController

  def show
    @user = User.find(params[:id])
  end

end

class LsCommentsController < ApplicationController

  def create
    @ls_comment = LsComment.create(ls_comment_params)
    redirect_to l_story_path(@ls_comment.l_story)
  end

  private

  def comment_params
    params.require(:comment).permit(:content, :l_story_id, :user_id, user_attributes:[:name])
  end
end

class LStoriesController < ApplicationController
  def show
    @l_story = LStory.find(params[:id])
    @ls_comment = @l_story.comments.build
    @user = @ls_comment.build_user
    #for belongs_to relationship
  end

  def index
    @l_stories = LStory.all
  end

  def new
    @l_story = LStory.new
  end

  def create
    @l_story = LStory.create(l_story_params)
    redirect_to l_story_path(@l_story)
  end

  private

  def l_story_params
    params.require(:l_story).permit(:content, category_ids:[], categories_attributes: [:name])
    #notice that l_story doesn't have anything about user in its params
  end
end

USER views
show
<h1><%= @user.name %></h1><br>

<h3>Living Stories You Have Contributed To:</h3>
<% @user.l_stories.each do |ls| %>
<%= link_to p.title, l_story_path(ls) %>
<% end %>

LSTORY views
new
<%= form_for @l_story, url: l_stories_path do |f| %>
<%= f.label :title %>
<%= f.text_field :title %><br><br>
<%= f.label :content %><br>
<%= f.text_area :content %><br><br>
<%= f.submit "Create l_story"%>
<% end %>

show
<h1>Living Stories</h1>

<%= @l_story.title %><br>
<%= @l_story.content %><br>
<% end %><br><br>


<% @l_story.comments.each do |c| %>
    <%= c.user.name%> says: <%= c.ls_content %><br>
<% end %><br><br>


<h4>Users who have added to this l_story:</h4>

<% @l_story.users.uniq.each do |u|%>

<li><%= link_to u.username, user_path(u) %></li>
<%# user_path(u) worked because I passed in the whole object as a parameter %>
<% end %>

<h3>Make a comment</h3>

<%= form_for @comment do |f| %>
    <%= f.text_area :content %><br><br>
    <label>Choose Your Profile Name ... </label><br><br>
    <%= f.collection_select :user_id, User.all, :id, :username %><br><br><br>
    <%= f.label "Or Make a New Profile" %><br>
    <%= f.fields_for :user, @user do |lsc_user|%>
        <%= lsc_user.text_field :name %>
    <% end %>
    <%= f.hidden_field :l_story_id %>
    <%= f.submit "Keep the Story Going!"%><br><br>  
<% end %>

lsc_content
ls_content


FEATURE NOTES

<% @l_story.categories.each do |c| %>
    <%= c.name  %>

l_story_user
  accepts_nested_attributes_for :user, :reject_if => :all_blank

      <label>Choose a Category ... </label><br><br>
<%= f.collection_check_boxes :category_ids, Category.all, :id, :name %><br>
<%= f.fields_for :categories, @l_story.categories.build do |categories_fields|%>
<%= f.label "Or Make a New Category" %><br>
<%= categories_fields.text_field :name %>
<% end %><br><br>


  # def user_attributes=(user_attributes)
  #   user_attributes.values.each do |user_attribute|
  #     user = User.find_or_create_by(user_attribute)
  #     self.users << category
  #   end 
  # end



    def l_story_title
        self.try(:l_story).try(:title)
    end
    # but how does this work from just the parameters??? what mechanism takes what instance through the strong params and how does it do it?
    def l_story_title=(title)
        lst = LStory.find_by(title: title)
        self.l_story = l_story
    end


<h1><%= @l_story.title %></h1><br>
<h3>By: Everyone here!</h3><br>

<%# <h3>Genre/s: <% @l_story.o_genres.each do |og| %>
<%# <%= og.name %>
<%# <% end %>
<%# @l_story.o_genre %>
<p><%= @l_story.content %></p>

<h3>choose this l_story  ...</h3>
        <%= f.text_field :l_story_title, list: "l_stories_autocomplete" %>    <br><br>

    <%= f.submit "Submit" %>
        <datalist id="lit_fan_authors_autocomplete">
            <% LStory.all.each do |ls| %>
            <option value="<%= ls.title %>">
        <% end %>

<% @l_story.ls_comments.each do |c| %>
    <%# <%= c.user.name%>
    <%= c.content %><br>
<% end %>

<h1>Welcome to Living Story!</h1>


<%= render partial: "errors" %>

<p>This is how Living Story works: Choose a genre, create a title, and begin a story. You can write as many lines as possible, but do not finish the story. It is up to you and your fellow SFSourcerites to keep the story going!   </p>
<%= form_for(@l_story) do |f| %>
<%# story_creator %>
  <%= f.label "Title" %>
  <%= f.text_field :title %><br>
  <%= f.label "Content" %>
  <%= f.text_area :content %><br>
  <%= f.label "Choose an OpenGenre ... " %>
  <%= f.collection_check_boxes :ls_genre_ids, OGenre.all, :id, :name %><br>
  <%= f.label "Or make one" %>
  <%= f.fields_for :ls_genre_ids, @l_story.o_genres.build do |o_genres_fields| %>
    <%= o_genres_fields.text_field :name %>
  <% end %>
  <%= f.submit %>
<% end %>
<%# <%= f.collection_check_boxes :category_ids, Category.all, :id, :name %>
  <%# <%= f.fields_for :categories, post.categories.build do |categories_fields| %> 
    <%# <%= categories_fields.text_field :name %>
  def l_story_params
    params.require(:l_story).permit(:title, :content, o_genre_ids:[], o_genres_attributes: [:name])
  end


  # def index
  #   @l_stories = LStory.all
  # end
 
  # def new
  #   @l_story = LStory.new
  # end

  # def create  
  #   @l_story = LStory.new(l_story_params)
  #   raise params.inspect
  #   if @l_story.valid?
  #     @l_story.save
  #     redirect_to l_story_path(@l_story)
  #   else
  #     render :new
  #   end
  # end

  # def show
  #     @l_story = LStory.find(params[:id], :ls_genre_id) 
  #     # @pledges = Pledge.where(:l_story_id == @l_story.id)
  # end

# # b_fp = FundingProject.create!(title: "Test Fp", description: "test", funding_goal: "200")
# # a_fpcreator = FpCreator.create!(creator_name: "ac", location: "tampa")
# # # a_pledge = Pledge.create(amount: 20)
# # a_backer = FpBacker.create!(name: "a", backer_email: "a@a.com")
# b_pledge = Pledge.create!(amount: 10, funding_project_id: 1, fp_backer_id: 1)

  
   # get '/sessions', to: 'sessions#create'
  # post '/sessions', to: 'sessions#create'
 # get '/auth/facebook/callback' => 'sessions#create'
   # get '/sf_film_fanvorites', to: 'static#sf_film_fanvorites'
  # get '/sf_game_fanvorites', to: 'static#sf_game_fanvorites'
  # get '/sourcer_projects', to: 'static#sourcer_projects'

 # resources :funding_projects
  # resources :fp_creators
  # resources :pledges
  # resources :fp_backers
  # resources :sf_favs
  
  # resources :users do
  #   resources :sf_favs, only: [:new, :show, :edit]
  # end



      # @pledges = Pledge.where(:user_id == @user.id)
      # params[:user][:sf_favs_attributes][:fav_lits] = "(left blank)"
      # params[:user][:sf_favs_attributes][:fav_films] = "(left blank)"
      # params[:user][:sf_favs_attributes][:fav_games] = "(left blank)"
      # def new
      #   @user = User.new
      #   # @user.sf_favs.build
      # end
        # if params[:user][:sf_favs_attributes][:fav_lits] == nil && params[:user][:sf_favs_attributes][:fav_films] == nil && params[:user][:sf_favs_attributes][:fav_games] == nil

    # if params[:user][:sf_favs_attributes][:fav_lits] == "" || params[:user][:sf_favs_attributes][:fav_films] == "" || params[:user][:sf_favs_attributes][:fav_games] == ""
    # if params[:user][:sf_favs_attributes][:fav_lits] == "left blank" && params[:user][:sf_favs_attributes][:fav_films] == "left blank" && params[:user][:sf_favs_attributes][:fav_games] == "left blank"

    #   # params[:user][:sf_favs_attributes][:fav_lits] = "(left blank)"
    #   # params[:user][:sf_favs_attributes][:fav_films] = "(left blank)"
    #   # params[:user][:sf_favs_attributes][:fav_games] = "(left blank)"  
    #   @user = User.update(user_params_no_sf_favs)
    #   redirect_to user_path(@user)  
    # else
  # def user_params_no_sf_favs
  #   params.require(:user).permit(:name, :email, :password, sf_favs_attributes: [fav_lits: "left blank", fav_films: "left blank", fav_games: "left blank"])
  # end

  # def user_params_no_sf_favs_on_edit
  #   params.require(:user).permit(:name, :email, :password)
  # end




      
    #         def create
    #             user = User.find_or_create_by(:uid => auth['uid']) do |user|
    #               user.name = auth['info']['name']
    #         #  binding.pry
    #             end
    #             session[:user_id] = user.try(:id)
    #             redirect_to root_url
    #           end
    # #     if # request.env["omniauth.auth"]
    # #     @user = User.find_or_create_by(uid: auth['uid']) do |u|
    # #     u.name = auth['info']['name']
    # #     u.email = auth['info']['email']
    # #     u.image = auth['info']['image']

    # #             binding.pry
    # # #   end
    # # #   if @user if @user.persisted?
    # #           end
    # #     session[:user_id] = @user.id

    #     redirect_to root_path
    # #   else 
    # #     redirect_to root_path
    # #   end
    # end

            # user = User.find_or_create_by(uid: auth[:uid]) do |u|
            #     u.name = auth['info']['name']
        #         end
        # if user
        #         session[:user_id] = user.id
        #         # try(:uid)
        #     redirect_to root_path
        # else
        #     redirect_to(controller: 'sessions', action: 'new')
        # end
        # else
        #     redirect_to(controller: 'static', action: 'sf_lit_fanvorites')
            

        #     user = User.find_by(email: params[:sessions][:email])
        #     authenticated = user.try(:authenticate, params[:sessions][:password])
        # # return head(:forbidden) unless authenticated
        #         session[:user_id] = user.id
        #         redirect_to user_path(user)
        #     else
        #         redirect_to(controller: 'sessions', action: 'new')
        #     end
    #     end
    # end

    # def create
    #   @user = User.find_or_create_by(uid: auth['uid']) do |u|
    #     u.name = auth['info']['name']
    #     u.email = auth['info']['email']
    #     u.image = auth['info']['image']
    #   end
    # #   if @user if @user.persisted?
    #     session[:user_id] = @user.id

    #     redirect_to root_path
    # #   else 
    # #     redirect_to root_path
    # #   end
    # end


#     def create
#         if request.env['omniauth.auth']
#           user = User.create_with_omniauth(request.env['omniauth.auth'])
#           session[:user_id] = user.id    
#           redirect_to user_path(user.id)
#         else
#           user = User.find_by_email(params[:email])
#           user && user.authenticate(params[:password])
#           session[:user_id] = user.id
#           redirect_to user_path(user.id)
#         end
#       end
#     # def create
#     #     user = User.find_or_create_by(uid: auth[:uid]) do |u|
#     #         u.name = auth['info']['name']
#     #     end
#     #         session[:user_id] = user.try(:id)

#     #     # render 'welcome/home'

#     # end


#     def destroy
#         reset_session
#         session[:user_id] = nil
#         redirect_to login_path
#     end
# end     

# private 

# def auth
#     request.env['omniauth.auth']
# end

        # if session[:user_id]
        # @current_user = nil
        # session.delete :user_id
        # redirect_to login_path

        # def facebook
        #     @user = User.create_from_provider_data(request.env['omniauth.auth'])
        #     if @user.persisted?
        #       sign_in_and_redirect @user
        #       set_flash_message(:notice, :success, kind: 'Facebook') if is_navigational_format?
        #     else
        #       flash[:error] = 'There was a problem signing you in through Facebook. Please register or try signing in later.'
        #       redirect_to new_user_registration_url
        #     end 
        #   end

       # current_url = request.path
    # unless current_url == "/auth/facebook/callback"
    # end
                    # request.env['omniauth.auth']
                    # request.path -> "/auth/facebook/callback"
                    
                    # the user is using facebook signup/login 

 #$^+=!*()@%&
    # !#^$%&'*+-\/=?_`{|}~;
    #  !#$%&'*+-/=?^_`{|}~;

    

    # def self.find_or_create_by_omniauth(auth_hash)
    #     oauth_email = auth_hash[:info][:email]
    #     #starts with a request ... have to put request here this way bec. models don't do requests/anything to do with http
    #     where(:email => oauth_email).first_or_create do |user|
    #     #using .first as a way to recognize the record that's found by where; .find wouldn't work
    #     #because #where did that??? 
    #     #first_or_create_by do |user| passes local variables not already created(???) with user. to create and becomes part of the instantiation of that user
    #     #and is included in the object returned
    #     user.password = SecureRandom.hex
    #     #we do this to satisfy validations; it doesn't matter what we set as a password because the third-party password rules
    #     #sql ... where is select in sql and when a user with the email passed as self wasn't found then it made it an insert in sql
    #     end
    # end

    # def self.create_with_omniauth(auth)
    #     user = find_or_create_by(uid: auth['uid'], provider:  auth['provider'])
    #     user.email = "#{auth['uid']}@#{auth['provider']}.com"
    #     user.password = auth['uid']
    #     user.name = auth['info']['name']
    #     user.image = auth['info']['image']
    #     if User.exists?(user.id)
    #         # redirect_to root_url 
    #         user
    #     else
    #         user.save
    #         # redirect_to root_url 

    #         user
    #     end




    # has_many :user_sf_favs
    # has_many :sf_favs, through: :user_sf_favs
    # accepts_nested_attributes_for :sf_favs

    # has_many :user_user_roles
    # has_many :user_roles, through: :user_user_roles

    # def fp_creator_attributes=(fp_creator_attributes)
    #     fp_creator_attributes.values.each do |fpc_attribute|
    #     fpc = FpCreator.find_or_create_by(fpc_attribute) 
    #     self.fp_creators << fpc unless fpc.name == ""
    #     end 
    # end

    # before_save :make_name_titlecase

# private

#     def make_name_titlecase
#         self.name = self.name.titlecase
#     end

    # has_many :user_fp_creators 
    # has_many :fp_creators, through: :user_fp_creators
    # connect through abstract queries
    # has_many :user_fp_backers
    # has_many :fp_backers, through: :user_fp_backers
    # this may be better as a has many but not has many through, maybe depending on polymorphic with only other classes involved such as comments
    # connect through abstract queries

    # def fp_backer_connect_id
    #     self.try(:fp_backer).try(:connect_id)
    # end
    # # but how does this work from just the parameters??? what mechanism takes what instance through the strong params and how does it do it?
    # def fp_backer_connect_id=(connect_id)
    #     fpb = FpBacker.find_or_create_by(:connect_id: connect_id)
    #     self.fp_backer = fpb
    # end
    # has_many :user_fp_backers
    # has_many :fp_backers, through: :user_fp_backers

module LitFanAuthorsHelper
    # def display_author(lit_fan_work)
    #     lit_fan_work.lit_fan_author.nil? ? link_to("Add Author", edit_lit_fan_work_path(lit_fan_work)) : link_to(lit_fan_work.lit_fan_author_name, lit_fan_author_path(lit_fan_work.lit_fan_author))
    #   end
    
    # def lit_fan_author_select(lit_fan_author, lit_fan_work)
    #     if lit_fan_author
    #         lit_fan_author.name
    #     else
    #         select_tag "lit_fan_work[lit_fan_author_id]", options_from_collection_for_select(LitFanAuthor.all, :id, :name)
    #     end
    # end
end

  # def rejectable?(att)
  #   att['name'].blank? && new_record?
  # end


    # , reject_if: :rejectable?
    # proc { |attributes| attributes["name"].blank? }  

    # :all_blank, allow_destroy: 


      # joins(:lit_fan_works).group("lit_fan_author.id").order(title: :desc).limit(1)
      # binding.pry
      
      # having("COUNT(*) = 3").select("boats.*")
      # select authors where there are works
      # order the authors by most works asc limit 1 

          # def self.most_works
    #   self.lit_fan_works.sort.last
    # end


<%# <h3>Your SF Favorites: </h3>

    <ul>
        <% @user.sf_favs.each do |sf_fav| %>
        <li><%= sf_fav.fav_lit %></li>
        <li><%= sf_fav.fav_film %></li>
        <li><%= sf_fav.fav_game %></li>
    </ul>
        <% end %> %>


  # resources :users do
  #   resources :fp_creators
  #   # , only: [:index, :new, :show, :edit]
  # end

  # resources :funding_projects do
  #   resources :fp_creators, only: [:show]
  # end


  # resources :addresses
  # resources :fp_categories
  # resources :fp_comments
  # resources :l_stories
  # resources :ls_comments
  # resources :ls_genres


  # get 'fp_creators/index'
  # get 'fp_creators/new'
  # get 'fp_creators/show'
  # get 'fp_creators/edit'
  # get 'fp_creators/name'

  # namespace :admin do
  #   resources :funding_categories, only: [:new, :create, :edit, :update, :destroy]
  # end
  

  # resources :funding_projects
  
  # get "/funding_projects", to: "funding_projects#index"
  # post "/funding_projects", to: "funding_projects#create"
  # get "/funding_projects/new", to: "funding_projects#new"
  # get "/funding_projects/:id/edit", to: "funding_projects#edit"
  # get "/funding_projects/:id", to: "funding_projects#show"
  # patch "/funding_projects/:id", to: "funding_projects#update"
  # put "/funding_projects/:id", to: "funding_projects#update"
  # delete "/funding_projects/:id", to: "funding_projects#destroy"



  # resources :users do
  #   resources :addresses, only: [:new, :create, :show, :edit, :update]
  # end

# resources :fp_participant do
  #   resources :funding_projects, only: [:index, :show]
  # end
    
# resources :users do
  #   resources :funding_projects, except: [:index]
  # end
  
  # resources :l_stories do
  # #  only: [:new, :create, :show] do
  #   resources :ls_genres
    # , only: [:new, :create, :show]
  # end
 

  # resources :funding_projects do
  #   resources :funding_categories
    # , only: [:index, :show]
  # end

  # resources :fp_creators do
  #   resources :funding_projects
  # end  
  
  # resources :funding_projects do
  #   resources :fp_comments
  # end

  # resources :funding_categories do
  #   resources :
  # resources :users do
  #   resources :fp_comments
  # end

  def create
    if params[:user][:sf_favs_attributes][:fav_lits] == "" || params[:user][:sf_favs_attributes][:fav_films] == "" || params[:user][:sf_favs_attributes][:fav_games] == ""
      @user = User.new(user_params_no_sf_favs)
      if @user.valid?
        @user.save
        session[:user_id] = @user.id
        redirect_to user_path(@user)
      else
        render :new
      end  
    else
      @user = User.new(user_params)
      if @user.valid?
        @user.save
        session[:user_id] = @user.id
        redirect_to user_path(@user)
      else
        render :new
      end
    end
  end

  def show
      @user = User.find(params[:id]) 
      # @pledges = Pledge.where(:user_id == @user.id)
  end

  def edit

      @user = User.find(params[:id])
  end

  def update
    if params[:user][:sf_favs_attributes][:fav_lits] == "" || params[:user][:sf_favs_attributes][:fav_films] == "" || params[:user][:sf_favs_attributes][:fav_games] == ""
    # if params[:user][:sf_favs_attributes][:fav_lits] == "" || params[:user][:sf_favs_attributes][:fav_films] == "" || params[:user][:sf_favs_attributes][:fav_games] == ""
      @user = User.update(user_params_no_sf_favs)
      redirect_to user_path(@user)  
    else
      @user.sf_favs.each {|sffs|
        @sf
      
      
      }
      @sf_favs = @user.sf_favs.where(@user.id == :user_id)
      @sf_favs.update(user_params)
      redirect_to user_path(@user)
    end  
  end
<%# @lit_fan_authors.each {|name| name.alph_name } %>

<%# <% @lit_fan_authors.each do |lfa| %>
<%# <% end %> 
<%# <%= LitFanAuthor.author_most_works 

<%# <% @lit_fan_authors.all.each do |lfa|  
<%# <%= lfa.name if lfa.author_most_works  
<%# <% end  %>
<%# <%= LitFanAuthor.author_most_works %>
<h3>Total Pledges So Far:</h3>
<%= @funding_project.total_pledges.sum  %><br><br>

<% if @funding_project.total_pledges.sum < @funding_project.funding_goal %>
    <%= "Total Needed:" %>
    <%= @funding_project.total_pledges.sum - @funding_project.funding_goal %>
<% elsif @funding_project.total_pledges.sum == @funding_project.funding_goal %><br>
    <%= "Funding Goal Achieved!" %><br><br>
<% elsif @funding_project.total_pledges.sum > @funding_project.funding_goal %><br>
    <%= "Funding Goal Achieved!" %><br><br>
<%= "Total Over Funding Goal:" %>
    <%= @funding_project.total_pledges.sum - @funding_project.funding_goal %>
<% end %><br><br>


    <h2>Creator Profile</h2>
<% @funding_project.fp_creators.each do |fpc| %>
    <ul>
        <li><h2>Creator Profile</h2></li>
        <li>Creator: <%= fpc.creator_name %></li><br><br>
        <li>Location: <%= fpc.location %></li><br><br>
        <li>About Creator: <%= fpc.creator_about %></li><br><br>
        <li>Creator Website: <%= fpc.creator_site %></li><br><br>
        <li>Creator Instagram: <%= fpc.instagram_url %></li><br><br>
        <li>Creator Twitter:<%= fpc.twitter_url %></li><br><br>
        <li>Creator Facebook:<%= fpc.facebook_url %></li><br><br>
        <li>Creator Blog: <%= fpc.blog_url %></li>
    </ul>
<% end %>



<%# <h3>Select an SFSourcer Project by Category </h3> %>

<%# <h4><%= @funding_categories.each do |fc| %>
<%# <ul> %>
    <%# <li><%= link_to fc.name, funding_category_path(fc) %>
<%# </ul> %>
<%# <% end %> 

<%# <h3>SFSourcer Projects Nearing Final Countdown:</h3> %>

class FpCreatorsController < ApplicationController
  before_action :require_login
  skip_before_action :require_login, only: [:index, :show]
  
  def index
    if params[:user_id]
      @user = User.find_by(id: params[:user_id])
      # if @fp_creator.nil?
      #   redirect_to user_path, alert: "User not found"
      # else   
      # DON'T NEED THIS BECAUSE WILL ALWAYS HAVE AN AUTHOR OR BE VIEWABLE AS A USER WHO DOESN'T HAVE AN FpCreator ROLE
      @fp_creators = @user.fp_creators
    # # This is if I only want to show the user as well as its fp_creator .. perhaps a later option; check lit_fan)works_controller for more code
    else
      @fp_creators = FpCreator.all
    end
  end

  def new
    # if params[:user_id] && !User.exists?(id: params[:user_id])
    #   redirect_to user_path, alert: "User not found"
    # else
      @fp_creator = FpCreator.new(user_id: params[:user_id])
    # end
  end

  def create
      @fp_creator = FpCreator.create(fp_creator_params)
    
    # raise params.inspect
  
    # @fp_creator.lit_fan_works.build
      # = LitFanWork.where(fp_creator_id: params[:fp_creator_id])
    # if @fp_creator.save
      redirect_to @fp_creator
    # else
    #   render :new
    # end
  end

  def show
    if params[:user_id]
      @user = User.find_by(id: params[:user_id])
      @fp_creator = @user.fp_creators.find_by(id: params[:id])
    #   # only if user to be included here, too
    else
      @fp_creator = FpCreator.find(params[:id])
    end
  end

  def edit
    @fp_creator = FpCreator.find(params[:id])
  end

  def update
    @fp_creator = FpCreator.find(params[:id])

    @fp_creator.update(fp_creator_params)

      @fp_creator.save
      redirect_to fp_creator_path(@fp_creator)
      render :edit
  end

  # Namespace destroy
  def destroy
    @fp_creator = fp_creator.find(params[:id])
    @fp_creator.destroy
    flash[:notice] = "Author deleted."
    redirect_to fp_creators_path
  end

  private

  def require_login
    unless logged_in?
      flash[:alert] = "You must be logged in to access this section"
      redirect_to login_url
    end
  end

  def fp_creator_params
    params.require(:fp_creator).permit(
      :creator_name,
      :location,
      :creator_about,
      :creator_site,
      :instagram_url,
      :twitter_url,
      :facebook_url,
      :blog_url,    
      # "fpc_user_name"
    )
  end
end 
     # funding_projects_attributes: [:title, :description, :funding_goal]

    # @user = User.find_by(id: params[:user_id])
    # @funding_project = @user.funding_projects.find_by(id: params[:id])

  def fp_creator_params
    params.require(:fp_creator).permit(
      :name,
      :location,
      :creator_about,
      :creator_site,
      :instagram_url,
      :twitter_url,
      :facebook_url,
      :blog_url,
      :user_id,
      
      # "fpc_user_name"
    )
  end
end 
<h3>Total Pledges So Far:</h3>
<%= @funding_project.total_pledges.sum  %><br><br>

<% if @funding_project.total_pledges.sum < @funding_project.funding_goal %>
    <%= "Total Needed:" %>
    <%= @funding_project.total_pledges.sum - @funding_project.funding_goal %>
<% elsif @funding_project.total_pledges.sum == @funding_project.funding_goal %><br>
    <%= "Funding Goal Achieved!" %><br><br>
<% elsif @funding_project.total_pledges.sum > @funding_project.funding_goal %><br>
    <%= "Funding Goal Achieved!" %><br><br>
<%= "Total Over Funding Goal:" %>
    <%= @funding_project.total_pledges.sum - @funding_project.funding_goal %>
<% end %><br><br>



<%# <h3><%= link_to "Make a Pledge", new_pledge_path %>


<%# <h3>Select an SFSourcer Project by Category </h3> %>

<%# <h4><%= @funding_categories.each do |fc| %>
<%# <ul> %>
    <%# <li><%= link_to fc.name, funding_category_path(fc) %>
<%# </ul> %>
<%# <% end %> 

<%# <h3>SFSourcer Projects Nearing Final Countdown:</h3> %>


<%# <h3><%= link_to "Make a Comment", new_funding_project_comment_path %>

<%# <%= @funding_project.comments.each do |comment| %>
<%# <%= link_to comment.user.username, user_path(comment.user) %> 
<%# <%= comment.content %> 
<%# <% end   

<%# <% ready_for_countdown.each do |rfc|  
<ul>
<%# <li><%= rfc.amount  
</li>
</ul>
<%# <% end  
 , addresses_attributes: [:address1, :address2, :city, :state, :zip, :user_id], created_funding_project_attributes: [:creator_name, :title, :description]
    a = User.create(name: "a", email: "a@a.com", password: "a")
# aa fantastic_cats = FundingProject.create(creator_name: "Frank J Inc.", title: "Fantastic Cats", description: "A collection of short stories about cats with science fiction and fantasy settings.", funding_goal: 500, user_id: 1)
# frank_jones_cats_pledge = Pledge.create(amount: 10, user_id: 1, funding_project_id: 1)
aa = Address.create(address1: "100 Main Street", city: "Springfield", state: "Ohio", zip: "45454", user_id: 1)
 a = User.create(name: "a", email: "a@a.com", password: "a")
 
work1 = LitFanWork.create(title: "Dune")
author1 = LitFanAuthor.create(name: "Frank Herbert")
genre1 = LitFanGenre.create(name: "Classic Science Fiction")


# has_many :pledges
    # belongs_to :user
    # belongs_to :fp_creator, :class_name => "User"
    # belongs_to :fp_participant, :class_name => "User"
        # USER AS CREATOR
        # USER AS CONTRIBUTOR
    # has_many :users, through: :pledges
        # USER AS CONTRIBUTOR
    # has_many :fp_comments
        # USER AS CONTRIBUTOR
    # has_many :users, through: :fp_comments
        # USER AS CONTRIBUTOR

    # has_many :addresses
    # has_many :created_funding_projects, :foreign_key => "fp_creator_id", :class_name => "FundingProject"
    # has_many :participated_funding_projects, :foreign_key => "fp_participant_id", :class_name => "FundingProject"
    # accepts_nested_attributes_for :created_funding_projects
    # has_one :address
    # accepts_nested_attributes_for :address
    # has_many :pledges
    # has_many :funding_projects, through: :pledges
    # TO DO: THROUGH FP_PARTICIPANT ALIAS
    # has_many :ls_comments
    # has_many :l_stories, through: :ls_comments
    # has_many :fp_comments
    # has_many :funding_projects, through: :fp_comments
    # TO DO: THROUGH FP_PARTICIPANT ALIAS
    # has_many :l_stories
    # TO DO: THROUGH LS_CREATOR ALIAS
    # has_many :ls_genres
    # TO DO: THROUGH LS_CREATOR ALIAS

    # has_many :ls_genres
    # has_many :ls_genres, through: :l_stories
    # AS A CONTRIBUTOR

<h2>Address Information</h2>
<%= f.fields_for :addresses do |addr| %>
    <%= addr.label :address1 %>
    <%= addr.text_field :address1 %><br>
 
    <%= addr.label :address2 %>
    <%= addr.text_field :address2 %><br>
 
    <%= addr.label :city %>
    <%= addr.text_field :city %><br>
 
    <%= addr.label :state %>
    <%= addr.text_field :state %><br>
 
    <%= addr.label :zip %>
    <%= addr.text_field :zip %><br>

  <% end %><br><br>

<h3>Your Source Projects As a Creator</h3>
    <ul>
    <% @user.funding_projects.each do |ufp| %>
    <h4<li><%= ufp.title %></li><h4>
    <h4><li><%= ufp.description %></li></h4>
    <h4></h4><li><%= ufp.funding_goal %></li></h4>
    <% end %>
    </ul><br>


<h3><%= link_to "Make a New Sourcer Project", new_user_funding_project_path(@user) %>


<%# <h2><%= link_to "Your Sourcer Projects", funding_projects_url(user_fp_creator) %> 

<h3>Your Pledges/Sourcer Projects as Contributor: </h3>
<ul>
    <%# make into link %>
    <li><h3><% @pledges.each do |p| %></h3></li>
    <li><h3>Sourcer Project: <%= p.funding_project.title %></h3></li>
    <li><h3>Amount: <%= p.amount %></h3></li>
        <% end %>
</ul>
<br><br>

<h3>Sourcer Projects You've Commented on: </h3>
        <%# <% end %> %> %>

<%# <% @user.funding_projects.each do |fp| %> %>
<%# <%= link_to funding_project.title, funding_project_path(fp) %> %>
<%# <% end %> %>
 %>
<%# If user has their own project/s, they appear here: %><br><br>


  </div>

<h2>Address Information</h2>
<%= f.fields_for :addresses do |addr| %>
    <%= addr.label :address1 %>
    <%= addr.text_field :address1 %><br>
 
    <%= addr.label :address2 %>
    <%= addr.text_field :address2 %><br>
 
    <%= addr.label :city %>
    <%= addr.text_field :city %><br>
 
    <%= addr.label :state %>
    <%= addr.text_field :state %><br>
 
    <%= addr.label :zip %>
    <%= addr.text_field :zip %><br>

  <% end %><br><br>

<h2>Let us know about your SF favorites!</h2>
    <%= f.fields_for :sf_favs do |sf_fave| %>
<h3>What are your favorite SF literary works?</h3>    
<%# <ol> %>
      <li><%= sf_fave.text_field :fav_lits %><br></li>
    <%# </ol> %>
 
<h3>What are your favorite SF films?</h3>    
        <%# <ol> %>
      <li><%= sf_fave.text_field :fav_films %><br></li>
    <%# </ol>  %>
<h3>What are your favorite SF games?</h3>    
        <%# <ol> %>
      <li><%= sf_fave.text_field :fav_games %><br></li>
    <%# </ol>  %>
  <% end %>

  def index
    @lit_fan_authors = LitFanAuthor.search(params[:term])

    # @lit_fan_authors = LitFanAuthor.all
    # @tasks = Task.search(params[:term])
    # @lit_fan_works = @lit
  end

<h2>For checking out or recommending a specific work, browse through all the works or search for a specific one.

<h3>Go to <%= link_to 'All Works Fanvorites', lit_fan_works_path %></h3>

<h3>Search for a Work: </h3>


<h2>For checking out works and authors by genre, browse through all the genres or search for a specific one.

<h3>Go to <%= link_to 'All Fanvorite Genres', lit_fan_genres_path %></h3>

<h3>Search for a Work: </h3>


    <%= f.label "Find or write the work's title below:" %><br>
    <%= f.text_field :title, list: "lit_fan_works_autocomplete" %>
    <datalist id="lit_fan_works_autocomplete">
    <% LitFanWork.all.each do |lfw| %>
    <option value="<%= lfw.title %>">
    <% end %>
<%# <h4>Choose the author from the list of recommended authors below ... </h4> %>
    <%# <%= lit_fan_author_select(@lit_fan_work.lit_fan_author, @lit_fan_work) %><br><br> 
    <%# <h4>or add a new one ...</h4> %>
<%# However, we've lost the ability for users to create their own categories.
That might be what you want. For example, the content management system for a magazine would probably want to enforce that the category of an article is one of the sections actually printed in the magazine.
In our case, however, we want to give users the flexibility to create a new category or pick an existing one. What we want is autocompletion, which we can get with a datalist:
<%= form_for @post do |f| %>
 <%# <%= f.text_field :category_name, list: "categories_autocomplete" %> %>
 <%# <datalist id="categories_autocomplete"> %>
   <%# <% Category.all.each do |category| %> %>
     <%# <option value="<%= category.name %>"> %>
   <%# <% end %> %>
 <%# </datalist> %>
 <%# <textarea name="post[content]"></textarea> %>
<%# <% end %> %>
<%# datalist is a new element in the HTML5 spec that allows for easy autocomplete. Check below in Resources for further reading. %> %>
# This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rails db:seed command (or created alongside the database with db:setup).
#
# Examples:
#
#   movies = Movie.create([{ name: 'Star Wars' }, { name: 'Lord of the Rings' }])
#   Character.create(name: 'Luke', movie: movies.first)
frank_jones = User.create(name: "Frank Jones", email: "frankjones@yahoo.com", password: "frank jones password")
fantastic_cats = FundingProject.create(creator_name: "Frank J Inc.", title: "Fantastic Cats", description: "A collection of short stories about cats with science fiction and fantasy settings.", funding_goal: 500, user_id: 1)
# frank_jones_cats_pledge = Pledge.create(amount: 10, user_id: 1, funding_project_id: 1)
# frank_jones_address = Address.create(address1: "100 Main Street")
# new_story = LStory.create(title: "b", content: "b")
# new_genre = OGenre.create(name: "b")


 [x] Choose or make a new creator with the new form for new fp 
 [x] funding_project_creator can have different name, other profile info, but will be same :id and login for a user

  # resources :users do
  #   resources :funding_projects, only: [:index, :show, :new, :edit]
  # end
  # resources :funding_projects

  
  # def addresses_index
  #   @user = User.find(params[:id])
  #   @addresses = @user.addresses
  #   render template: 'addresses/index'
  # end
 
  # def post
  #   @user = User.find(params[:id])
  #   @address = Address.find(params[:user_id])
  #   render template: 'addresses/show'
  # end

class FundingProjectsController < ApplicationController
  before_action :require_login
  # skip_before_action :require_login, only: [:index, :show]
  # before_save :make_titlecase

  def index
    @funding_projects = FundingProject.all
    # @user = User.find_by(id: params[:user_id])
    # @funding_projects = @user.funding_projects
  end

  # def comments_index
  #   @funding_project = FundingProject.find(params[:id])
  #   @comments = @funding_project.comments
  #   render template: 'comments/index'
  # end

  # def comment
  #   @funding_project = FundingProject.find(params[:id])
  #   @funding_project.comment.id = Comment.find(params[:id])
  #   render template: 'comments/show'
  # end

  def new
    @funding_project = FundingProject.new

    # @user = User.find(params[:id])
    # @user = User.find_by(id: params[:id])



    # @funding_project.comments.build
    # @funding_project.user_id = current_user
    # @comment = @comment.find_by(:id)
    # @funding_project.id = @comment.fundng_project_id
    # @funding_project.comments.build
  end

  def create
    
    @funding_project = FundingProject.new(funding_project_params)
    @user = User.find_by(id: params[:user_id])
    @funding_project = @user.funding_projects.find_by(id: params[:id])
    
    # @user = User.find(params[:id])
    @funding_project.save

    redirect_to user_funding_project_path(@user, @funding_project)
    # binding.pry


    # @funding_project.fp_creator_id = current_user.id
    # fp = @funding_project
    # fp.save
    # current_user.funding_projects << fp
    # @user.funding_projects << funding_project
    # @funding_project = @user.funding_projects.last
    # binding.pry
    # if @funding_project.valid?

    # raise params.inspect
    # binding.pry
    # @funding_project.fp_creator_id = 
    # @funding_project.fp_creator_id = FpCreator.where(:id == current_user.id)
    # if @funding_project.valid?
      # fp_pledges = @funding_project.pledges
      # @user = User.find_by(id: params[:user_id])

    # @user = current_user
    # @funding_project = @user.funding_projects.last
    # binding.pry
    # redirect_to fp_creator_funding_project_path(@user, @funding_project.id)
    # else
      # funding_project_path(@funding_project)
    # else
    #   render :new
    # end
    end

  def show
    @user = User.find_by(id: params[:user_id])
    @funding_project = @user.funding_projects.find_by(id: params[:id])
    # @funding_project = FundingProject.find(params[:id])
    # NOTE: Above doesn't work because there needs to be an association in the first place, not finding a funding_project
    @total_pledges = []
    # @comments = Comment.where(:funding_project_id == @funding_project.id)
  end

  def edit
    #make editong an already made FP instance possible
  end

  def update
    #update an already made FP instance, including saving it
  end

  def destroy
  end

  private

  def funding_project_params
    params.require(:funding_project).permit(
      :creator_name,
      :fp_participant_id,
      :fp_creator_id,
      # :funding_project_pledge,
      :title,
      :description, 
      :funding_goal, 
      # comments_attributes: [:title, :content]
      :user_id)
  end

  # def fp_creator_params
  #   params.require(:fp_creator).permit(
  #     "name",
  #     "location",
  #     "name_of_verified",
  #     "verified?",
  #     "creator_profile",
  #     "last_logged_in",
  #     "fp_amt_created",
  #     "fp_amt_backed",
  #     "creator_site",
  #     "instagram_url",
  #     "twitter_url",
  #     "facebook_url",
  #     "blog_url",
  #     "user_id",
  #     funding_projects_attributes: [:title, :description, :funding_goal]
  #   )
  # end


  def require_login
    unless logged_in?
      flash[:alert] = "You must be logged in to access this section"
      redirect_to login_url
    end
  end


#   def total_pledges
#     self.pledges.each do |p| 
#        p.amount  
#     end
# end

end
[ ] Making living story feature, to include OpenGenre feature, with OpenGenres to be nested under Living Story
l_story_1 = LStory.new(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genre_id => 1, :ls_genre_attributes => {:id => 1, :name => "Fantasy"})
l_story_2 = LStory.create(:title => "My Second Living Story", :content => "It was a dark but not as stormy morning ...",
l_story_1 = LStory.create(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genres_attributes => {:id => 1})

=> #<OGenre id: 1, name: "Fantasy", user_id: nil, l_story_id: nil, created_at: "2018-07-28 16:57:36", updated_at: "2018-07-28 16:57:36">
2.3.3 :003 > l_story_1 = LStory.create(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genre_attributes => {:id => 2, :name => "Horrible Horror"})
ActiveModel::UnknownAttributeError: unknown attribute 'o_genre_attributes' for LStory.
        from (irb):3
2.3.3 :004 > l_story_1 = LStory.create(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genres_attributes => {:id => 2, :name => "Horrible Horror"})
ActiveRecord::RecordNotFound: Couldn't find OGenre with ID=2 for LStory with ID=
        from (irb):4
2.3.3 :005 > l_story_1 = LStory.create(:title => "My First Living Story", :content => "It was a dark and stormy morning ...", :ls_genres_attributes => {:id => 1})
ActiveRecord::RecordNotFound: Couldn't find OGenre with ID=1 for LStory with ID=
        from (irb):5
2.3.3 :006 > l_story_2 = LStory.create(:title => "My Second Living Story", :content => "It was a dark but not as stormy m


<%= f.label "Name of Sponsoring Individual or Organization (Creator) "%>
<%= f.text_field :name %><br>
<%= f.label "Location "%>
<%= f.text_field :location %><br>
<%= f.label "Name of Verified for Project "%>
<%= f.text_field "name_of_verified" %><br>
<%= f.label "About Creator "%>
<%= f.text_area "creator_about" %><br>
<%= f.label "Creator Website "%>
<%= f.text_field "creator_site" %><br>
<%= f.label "Instagram "%>
<%= f.text_field "instagram_url" %><br>
<%= f.label "Twitter "%>
<%= f.text_field "twitter_url" %><br>
<%= f.label "Facebook "%>
<%= f.text_field "facebook_url" %><br>
<%= f.label "Blog "%>
<%= f.text_field "blog_url" %><br>
<%= f.submit %>
<% end %>

<h1>Creator Profile for <%= @fp_creator.name %></h1><br>
<h3>Connected to User <%= @current_user.name %></h3>

<p>Name: <%= @fp_creator.name %></p>
<p>Location: <%= @fp_creator.location %>
<p>Name of Verified: <%= @fp_creator.name_of_verified %>
<p>About Creator: <%= @fp_creator.creator_about %>
<p>Creator Website: <%= @fp_creator.creator_site %>
<p>Creator Instagram: <%= @fp_creator.instagram_url %>
<p>Creator Twitter:<%= @fp_creator.twitter_url %>
<p>Creator Facebook:<%= @fp_creator.facebook_url %>
<p>Creator Blog: <%= @fp_creator.blog_url %><br><br>

<h2><%= link_to "Make a New Sourcer Project for this Creator", new_funding_project_path %> </h2><br>

<h3>Edit Profile</h3>

class AdminController < ApplicationController
  before_action :require_admin

  def require_admin
    unless current_user.admin?
      redirect_to root_path
    end
  end
end
Now, each namespaced admin controller can inherit directly (and quite appropriately) from AdminController. Since weve defined the before_action in AdminController, actions in any sub-classed controller will be restricted to admin users by default.

We no longer need to list the before_action or define a require_admin method in each of our namespaced controllers; they just inherit from AdminController:

class Admin::CategoriesController < AdminController
  # Methods omitted
end





Unused Code:

class CreateJoinTable < ActiveRecord::Migration[5.2]
  def change
    create_join_table :fp_creators, :funding_projects do |t|
      # t.index [:fp_creator_id, :funding_project_id]
      # t.index [:funding_project_id, :fp_creator_id]
    end
  end
end

<!DOCTYPE html>
<html>
  <head>
    <title>RailsAmusementPark</title>
    <%= csrf_meta_tags %>

    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        <a class="navbar-brand" href="<%= root_url %>"/>Home</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <% if current_user %>
              <li><%= link_to "Hello, #{current_user.name}!", user_path(current_user) %></li>
              <li><%= link_to "Attractions", attractions_path %></li>
              <li><%= link_to "Log Out", signout_path, method: :delete %></li>
            <% else %>
              <li><%= link_to "Sign Up", new_user_path %></li>
              <li><%= link_to "Sign In", signin_path %></li>
            <% end %>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <!-- content -->
    <div class="container"  role="main">
      <%= yield %>
    </div>
  </body>
</html>

  <h3>Make a Comment About This Project!</h4>
<%= form_for :comment, action: :new, url: 'new_comment_path' do |f| %>
<%= f.label :title %>
<%= f.text_field :title %><br>
<%= f.label "What do you think?" %>
<%= f.text_area :content %><br>
<%= f.submit "Submit"%>
<% end %>

# get 'addresses/index'
  # get 'addresses/new'
  # get 'addresses/create'
  # get 'addresses/show'
  # get 'addresses/edit'
  # get 'addresses/update'
  # get 'addresses/destroy'

  # resources :funding_projects do 
  #   resources :fp_comments
  # end

  #can only destroy a funding project as admin

  # get 'pledges/new'
  # get 'pledges/create'
  # get 'pledges/show'
  # get 'pledges/edit'
  # get 'pledges/update'
  # get 'pledges/destroy'
  # get 'funding_projects/index'
  # get 'funding_projects/new'
  # get 'funding_projects/create'
  # get 'funding_projects/show'
  # get 'funding_projects/edit'
  # get 'funding_projects/update'
  # get 'funding_projects/destroy'
  # get 'users/index'
  # get 'users/new'
  # get 'users/create'
  # get 'users/show'
  # get 'users/edit'
  # get 'users/update'
  # get 'users/destroy'


               # oauth_email = request.env["omniauth.auth"][:info][:email]
            #     session[:user_id] = user.id
            #     redirect_to root_path
            # else 
            #     user = User.new(:email => oauth_email, :password = SecureRandom.hex)
            # if user.save
            #     session[:user_id] = user.id
            # else
            #     raise user.errors.full_messages.inspect

         # new_user_pledge = User.where(:id == @pledge.user_id)
    # @pledge.user_id = new_user_pledge    

    
    
    # @pledge = Pledge.where(:funding_project_id == @funding_project.id)
    # pledge = Pledge.create(params[:amount])
    # @funding_project.pledges < pledge

   # def create
#   @user = User.find_or_create_by(uid: auth['uid']) do |u|
#     u.name = auth['info']['name']
#     u.email = auth['info']['email']
#     u.image = auth['info']['image']
#   end

#   session[:user_id] = @user.id

#   render 'welcome/home'
# end

# private

# def auth
#   request.env['omniauth.auth']
# end

# <% if session[:user_id] %>
#   <h1><%= @user.name %></h1>
#   <h2>Email: <%= @user.email %></h2>
#   <h2>Facebook UID: <%= @user.uid %></h2>
#   <img src="<%= @user.image %>">
# <% else %>
#   <%= link_to('Log in with Facebook!', '/auth/facebook') %>
# <% end %>


    current_funding_project = FundingProject.where(@pledge.user_id == current_user)
binding.pry
    project_pledges = current_funding_project.pledges 

    new_pledge_save = @pledge 
    
    project_pledges << new_pledge_save 

    @pledge = new_pledge_save



<h2>Make a pledge for this project:</h2><br>
<%= form_for @funding_project do |f| %>
<h4>Pledge Amount (in U.S. dollars) <%= f.text_field :funding_project_pledge %></h4>
<%= f.submit "Make a Pledge"%>
<% end %>

<%# <p>Amount Pledged: <%= @funding_project.funding_goal %> </p><br> %>

<%# if @pledge.user_id == @funding_project.id %>
<%# make a form that lets you pledge right there
set @pledge form for
text_box for amount
makes use of @funding_project --- hidden param?
    or make it a collection nested hash
user_id assocation is easy, from sessions
direct to pledges#show %>

<%= form_for(@pledge) do |f| %> %>
<%# <%= @funding_project.id = @pledge.funding_project_id %> %>
<%= f.text_field :amount %>
<%= f.hidden :funding_project_id %>
<%= f.submit "Make a Pledge"%>
<% end %>



<%# <h2><%= link_to "Click here to make a pledge for this project (in U.S. dollars)", new_pledge_path %></h2><br> %>
<%# <%= form_for @funding_project do |f| %> %>
<%# <h4>Pledge Amount  <%= f.text_field :amount %></h4> %>
<%# <%= f.submit "Make a Pledge"%> %>
<%# <% end %> %>




<%# <%= link_to '/pledges/new', pledges_path%> %>


